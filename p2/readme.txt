The input trains.txt file is read line-by-line, where each line is represented by a train, with its corresponding direction, loading and crossing times being assigned to each of them. This information is saved into an overall train struct that holds the following attribute for each train instance: train number, priority, direction, loading time, crossing time and ready status. Each station, east and west, is represented by a priority queue. The priority queue is implemented using a linked list. Data for each node in the list is saved in a separate struct, where each node of the priority queue has the following attributes: priority, train data and a pointer to the next node in the list. There are three functions associated with the priority queue: push, pop and is_empty. The push function adds a train to the front of the priority queue if it satisfies the following property: if two trains have the same loading times, push the train that appears first in the input file. If the condition is not met: the function loops until it finds two such trains; if there are still no two trains, the current train gets added after the head node in the list. The pop function removes the desired node from the linked list, moves the head pointer over one and frees the associated memory. The is_empty function checks if the head of the node is empty (NULL) and returns true if the condition is met or false otherwise.

There is a single mutex for the east and west stations so that multiple trains can not be concurrently pushed or popped from the priority queue. There is a mutex for the main track so that no two trains can collide during dispatch. There are two condition variables, one to signal when a train has been loaded after creation and the other to signal when a train is ready to cross the main track. A timer is used to track the simulation time of each train; this is achieved by appropriately sleeping the program for each load and cross interval. 
